### 1. Naming Conventions

Following PEP 8 (Python Enhancement Proposal 8) style guide.

#### Variables and Functions

```python
# Use snake_case for variables and functions
user_name = "Alice"
total_count = 100

def calculate_total_price(items):
    pass

# Use descriptive names
# Bad
x = 10
def proc():
    pass

# Good
max_retries = 10
def process_payment():
    pass
```

#### Constants

```python
# Use UPPERCASE with underscores
MAX_CONNECTIONS = 100
DEFAULT_TIMEOUT = 30
API_BASE_URL = "https://api.example.com"
```

#### Classes

```python
# Use PascalCase (CapWords) for class names
class UserProfile:
    pass

class DatabaseConnection:
    pass

class HTTPRequestHandler:
    pass
```

#### Private Members

```python
class BankAccount:
    def __init__(self):
        self.account_number = "123"  # Public
        self._balance = 1000          # Protected (convention)
        self.__pin = "1234"           # Private (name mangling)
```

#### Module and Package Names

```python
# Use short, lowercase names, avoid underscores if possible
# Good: utils.py, database.py, api_client.py
# Bad: Utils.py, DataBase.py, API-Client.py
```

---

### 2. Docstrings

Documentation strings that describe modules, classes, methods, and functions.

#### Function Docstrings

```python
def calculate_area(length, width):
    """
    Calculate the area of a rectangle.
    
    Args:
        length (float): The length of the rectangle.
        width (float): The width of the rectangle.
    
    Returns:
        float: The area of the rectangle.
    
    Raises:
        ValueError: If length or width is negative.
    
    Example:
        >>> calculate_area(5, 3)
        15.0
    """
    if length < 0 or width < 0:
        raise ValueError("Dimensions must be positive")
    return length * width
```

#### Class Docstrings

```python
class Employee:
    """
    Represents an employee in the organization.
    
    Attributes:
        name (str): The employee's full name.
        employee_id (str): Unique identifier for the employee.
        salary (float): Annual salary in dollars.
    
    Methods:
        give_raise(amount): Increase the employee's salary.
        get_details(): Return formatted employee information.
    """
    
    def __init__(self, name, employee_id, salary):
        """
        Initialize a new Employee instance.
        
        Args:
            name (str): The employee's full name.
            employee_id (str): Unique identifier.
            salary (float): Initial annual salary.
        """
        self.name = name
        self.employee_id = employee_id
        self.salary = salary
    
    def give_raise(self, amount):
        """
        Increase the employee's salary.
        
        Args:
            amount (float): The raise amount in dollars.
        
        Returns:
            float: The new salary amount.
        """
        self.salary += amount
        return self.salary
```

#### Module Docstrings

```python
"""
User Authentication Module

This module provides functions for user authentication and authorization.
It includes password hashing, token generation, and session management.

Usage:
    from auth import authenticate_user, generate_token
    
    user = authenticate_user(username, password)
    token = generate_token(user)

Author: Your Name
Date: 2025-10-05
Version: 1.0
"""
```

---

### 3. Comments

Comments explain **why**, not **what**. Code should be self-explanatory for the "what".

```python
# Bad: Stating the obvious
# Increment counter by 1
counter += 1

# Good: Explaining why
# Skip the first row because it contains headers
counter += 1

# Bad: Unnecessary comment
x = x + 1  # Add 1 to x

# Good: Explaining business logic
# Apply 10% discount for orders over $100
if order_total > 100:
    order_total *= 0.9

# Use TODO comments for future improvements
# TODO: Add input validation for email format
# FIXME: This breaks when list is empty
# NOTE: This algorithm is O(nÂ²), consider optimization

# Multi-line comments for complex logic
"""
This algorithm uses dynamic programming to solve the knapsack problem.
Time complexity: O(nW) where n is number of items and W is capacity.
Space complexity: O(nW) for the memoization table.
"""
```

**Best Practices:**

- Write self-documenting code with clear variable/function names
- Use comments sparingly for complex logic
- Keep comments up-to-date with code changes
- Avoid commented-out code in production

---

### 4. Types of Testing

#### Unit Testing

Test individual components in isolation.

```python
import unittest

def add(a, b):
    return a + b

class TestMathFunctions(unittest.TestCase):
    
    def test_add_positive_numbers(self):
        result = add(2, 3)
        self.assertEqual(result, 5)
    
    def test_add_negative_numbers(self):
        result = add(-2, -3)
        self.assertEqual(result, -5)
    
    def test_add_zero(self):
        result = add(5, 0)
        self.assertEqual(result, 5)
    
    def setUp(self):
        """Run before each test method"""
        pass
    
    def tearDown(self):
        """Run after each test method"""
        pass

if __name__ == '__main__':
    unittest.main()
```

#### Integration Testing

Test how different modules work together.

```python
# Testing database and API integration
class TestUserAPI(unittest.TestCase):
    
    def setUp(self):
        self.db = TestDatabase()
        self.api = UserAPI(self.db)
    
    def test_create_and_retrieve_user(self):
        # Create user through API
        user_id = self.api.create_user("Alice", "alice@example.com")
        
        # Retrieve user from database
        user = self.db.get_user(user_id)
        
        self.assertEqual(user.name, "Alice")
        self.assertEqual(user.email, "alice@example.com")
```

#### Functional Testing

Test complete features from user perspective.

```python
# Testing a complete user registration flow
def test_user_registration_flow():
    # User fills registration form
    response = client.post('/register', data={
        'username': 'testuser',
        'email': 'test@example.com',
        'password': 'secure123'
    })
    
    # Verify account created
    assert response.status_code == 201
    
    # Verify confirmation email sent
    assert email_sent_to('test@example.com')
    
    # Verify user can login
    login_response = client.post('/login', data={
        'username': 'testuser',
        'password': 'secure123'
    })
    assert login_response.status_code == 200
```

#### Other Testing Types

- **Regression Testing**: Ensure new changes don't break existing functionality
- **Performance Testing**: Test application speed and scalability
- **Security Testing**: Test for vulnerabilities
- **Acceptance Testing**: Verify software meets business requirements

---

### 5. PEP 8 Style Guide

Python's official style guide for writing clean, readable code.

#### Indentation

```python
# Use 4 spaces per indentation level (never tabs)
def function():
    if condition:
        do_something()
```

#### Line Length

```python
# Maximum line length: 79 characters
# For docstrings/comments: 72 characters

# Breaking long lines
result = some_function(
    argument1, argument2,
    argument3, argument4
)

# Alternative
result = some_function(argument1, argument2,
                      argument3, argument4)
```

#### Blank Lines

```python
# Two blank lines before top-level functions and classes
def function1():
    pass


def function2():
    pass


class MyClass:
    pass


# One blank line between methods
class MyClass:
    def method1(self):
        pass
    
    def method2(self):
        pass
```

#### Imports

```python
# Import order:
# 1. Standard library
# 2. Third-party packages
# 3. Local application imports

import os
import sys

import requests
import numpy as np

from myapp.models import User
from myapp.utils import helper

# Avoid wildcard imports
# Bad: from module import *
# Good: from module import specific_function

# One import per line
# Bad: import os, sys
# Good:
import os
import sys
```

#### Whitespace

```python
# No whitespace immediately inside brackets
# Good: spam(ham[1], {eggs: 2})
# Bad: spam( ham[ 1 ], { eggs: 2 } )

# No whitespace before comma, semicolon, or colon
# Good: if x == 4: print(x, y); x, y = y, x
# Bad: if x == 4 : print(x , y) ; x , y = y , x

# Whitespace around operators
# Good: i = i + 1
# Bad: i=i+1

# No whitespace for default parameters in function definition
# Good: def function(arg1, arg2=None):
# Bad: def function(arg1, arg2 = None):
```

#### String Quotes

```python
# Use single or double quotes consistently
# Both are acceptable, but be consistent

# Good (pick one style)
name = 'Alice'
message = "Hello"

# Use the other quote to avoid escaping
text = "It's a beautiful day"
phrase = 'She said "Hello"'
```

---

### 6. SOLID Principles

Five design principles for maintainable object-oriented code.

#### S - Single Responsibility Principle

A class should have only one reason to change.

```python
# Bad: Class with multiple responsibilities
class User:
    def __init__(self, name):
        self.name = name
    
    def get_user_data(self):
        pass
    
    def save_to_database(self):
        pass
    
    def send_email(self):
        pass

# Good: Separate responsibilities
class User:
    def __init__(self, name):
        self.name = name
    
    def get_user_data(self):
        pass

class UserRepository:
    def save(self, user):
        pass

class EmailService:
    def send_email(self, user):
        pass
```

#### O - Open/Closed Principle

Open for extension, closed for modification.

```python
# Bad: Modifying existing code for new features
class PaymentProcessor:
    def process(self, payment_type):
        if payment_type == "credit_card":
            # Process credit card
            pass
        elif payment_type == "paypal":
            # Process PayPal
            pass
        # Need to modify this method for new payment types

# Good: Extend through inheritance
class PaymentProcessor:
    def process(self):
        raise NotImplementedError

class CreditCardProcessor(PaymentProcessor):
    def process(self):
        # Process credit card
        pass

class PayPalProcessor(PaymentProcessor):
    def process(self):
        # Process PayPal
        pass

# Add new processors without modifying existing code
class BitcoinProcessor(PaymentProcessor):
    def process(self):
        # Process Bitcoin
        pass
```

#### L - Liskov Substitution Principle

Derived classes must be substitutable for their base classes.

```python
# Bad: Violates LSP
class Bird:
    def fly(self):
        pass

class Penguin(Bird):
    def fly(self):
        raise Exception("Penguins can't fly!")

# Good: Proper abstraction
class Bird:
    def move(self):
        pass

class FlyingBird(Bird):
    def move(self):
        self.fly()
    
    def fly(self):
        pass

class Penguin(Bird):
    def move(self):
        self.swim()
    
    def swim(self):
        pass
```

#### I - Interface Segregation Principle

Clients shouldn't depend on interfaces they don't use.

```python
# Bad: Fat interface
class Worker:
    def work(self):
        pass
    
    def eat(self):
        pass

class Robot(Worker):
    def work(self):
        pass
    
    def eat(self):
        pass  # Robots don't eat!

# Good: Segregated interfaces
class Workable:
    def work(self):
        pass

class Eatable:
    def eat(self):
        pass

class Human(Workable, Eatable):
    def work(self):
        pass
    
    def eat(self):
        pass

class Robot(Workable):
    def work(self):
        pass
```

#### D - Dependency Inversion Principle

Depend on abstractions, not concrete implementations.

```python
# Bad: High-level module depends on low-level module
class MySQLDatabase:
    def save(self, data):
        # Save to MySQL
        pass

class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # Tightly coupled
    
    def save_user(self, user):
        self.db.save(user)

# Good: Both depend on abstraction
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def save(self, data):
        pass

class MySQLDatabase(Database):
    def save(self, data):
        # Save to MySQL
        pass

class PostgreSQLDatabase(Database):
    def save(self, data):
        # Save to PostgreSQL
        pass

class UserService:
    def __init__(self, database: Database):
        self.db = database  # Depends on abstraction
    
    def save_user(self, user):
        self.db.save(user)

# Usage
mysql_db = MySQLDatabase()
user_service = UserService(mysql_db)

# Easy to switch databases
postgres_db = PostgreSQLDatabase()
user_service = UserService(postgres_db)
```

---

### 7. DRY Principle

**Don't Repeat Yourself** - Avoid code duplication.

```python
# Bad: Repeated code
def calculate_rectangle_area(length, width):
    return length * width

def calculate_rectangle_perimeter(length, width):
    return 2 * (length + width)

def calculate_square_area(side):
    return side * side

def calculate_square_perimeter(side):
    return 4 * side

# Good: Reusable code
class Shape:
    def area(self):
        raise NotImplementedError
    
    def perimeter(self):
        raise NotImplementedError

class Rectangle(Shape):
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width
    
    def perimeter(self):
        return 2 * (self.length + self.width)

class Square(Rectangle):
    def __init__(self, side):
        super().__init__(side, side)

# Another example: Extract common logic
# Bad
def send_email_to_user(user):
    # Email setup code (repeated)
    # Send email

def send_email_to_admin(admin):
    # Email setup code (repeated)
    # Send email

# Good
def send_email(recipient, subject, body):
    # Common email logic
    pass

def send_email_to_user(user):
    send_email(user.email, "Welcome", "Welcome message")

def send_email_to_admin(admin):
    send_email(admin.email, "Alert", "Alert message")
```

---
