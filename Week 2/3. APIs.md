## CRUD Operations

**CRUD** = Create, Read, Update, Delete

### HTTP Methods for CRUD

```
CREATE  → POST
READ    → GET
UPDATE  → PUT/PATCH
DELETE  → DELETE
```

### Example Implementation

```python
import requests
import json

BASE_URL = "https://api.example.com"

# CREATE - POST
def create_user(name, email):
    """Create a new user"""
    url = f"{BASE_URL}/api/users"
    payload = {
        "name": name,
        "email": email,
        "age": 30
    }
    headers = {
        "Content-Type": "application/json",
        "Authorization": "Bearer your_token_here"
    }
    
    response = requests.post(url, json=payload, headers=headers)
    
    if response.status_code == 201:
        print("User created successfully!")
        return response.json()
    else:
        print(f"Error: {response.status_code}")
        return None

# Usage
new_user = create_user("Alice", "alice@example.com")
print(new_user)


# READ - GET (All records)
def get_all_users():
    """Get all users"""
    url = f"{BASE_URL}/api/users"
    headers = {
        "Authorization": "Bearer your_token_here"
    }
    
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        users = response.json()
        return users['data']
    else:
        print(f"Error: {response.status_code}")
        return None

# Usage
users = get_all_users()
for user in users:
    print(f"ID: {user['id']}, Name: {user['name']}")


# READ - GET (Single record)
def get_user_by_id(user_id):
    """Get a specific user by ID"""
    url = f"{BASE_URL}/api/users/{user_id}"
    headers = {
        "Authorization": "Bearer your_token_here"
    }
    
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        return response.json()['data']
    elif response.status_code == 404:
        print("User not found")
        return None
    else:
        print(f"Error: {response.status_code}")
        return None

# Usage
user = get_user_by_id(123)
print(user)


# UPDATE - PUT (Complete update)
def update_user(user_id, name, email, age):
    """Update entire user record"""
    url = f"{BASE_URL}/api/users/{user_id}"
    payload = {
        "name": name,
        "email": email,
        "age": age
    }
    headers = {
        "Content-Type": "application/json",
        "Authorization": "Bearer your_token_here"
    }
    
    response = requests.put(url, json=payload, headers=headers)
    
    if response.status_code == 200:
        print("User updated successfully!")
        return response.json()
    else:
        print(f"Error: {response.status_code}")
        return None

# Usage
updated_user = update_user(123, "Alice Smith", "alice.smith@example.com", 31)


# UPDATE - PATCH (Partial update)
def patch_user(user_id, **kwargs):
    """Update specific fields of user"""
    url = f"{BASE_URL}/api/users/{user_id}"
    payload = kwargs  # Only fields to update
    headers = {
        "Content-Type": "application/json",
        "Authorization": "Bearer your_token_here"
    }
    
    response = requests.patch(url, json=payload, headers=headers)
    
    if response.status_code == 200:
        print("User patched successfully!")
        return response.json()
    else:
        print(f"Error: {response.status_code}")
        return None

# Usage
patched_user = patch_user(123, email="newemail@example.com")


# DELETE
def delete_user(user_id):
    """Delete a user"""
    url = f"{BASE_URL}/api/users/{user_id}"
    headers = {
        "Authorization": "Bearer your_token_here"
    }
    
    response = requests.delete(url, headers=headers)
    
    if response.status_code == 204:
        print("User deleted successfully!")
        return True
    elif response.status_code == 404:
        print("User not found")
        return False
    else:
        print(f"Error: {response.status_code}")
        return False

# Usage
success = delete_user(123)
```

### Complete CRUD Class Example

```python
class UserAPI:
    """Complete CRUD operations for User API"""
    
    def __init__(self, base_url, token):
        self.base_url = base_url
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {token}"
        }
    
    def create(self, user_data):
        """Create a new user"""
        url = f"{self.base_url}/users"
        response = requests.post(url, json=user_data, headers=self.headers)
        response.raise_for_status()
        return response.json()
    
    def read_all(self, page=1, per_page=20):
        """Get all users with pagination"""
        url = f"{self.base_url}/users"
        params = {"page": page, "per_page": per_page}
        response = requests.get(url, params=params, headers=self.headers)
        response.raise_for_status()
        return response.json()
    
    def read_one(self, user_id):
        """Get a single user"""
        url = f"{self.base_url}/users/{user_id}"
        response = requests.get(url, headers=self.headers)
        response.raise_for_status()
        return response.json()
    
    def update(self, user_id, user_data):
        """Update complete user record"""
        url = f"{self.base_url}/users/{user_id}"
        response = requests.put(url, json=user_data, headers=self.headers)
        response.raise_for_status()
        return response.json()
    
    def partial_update(self, user_id, user_data):
        """Update specific fields"""
        url = f"{self.base_url}/users/{user_id}"
        response = requests.patch(url, json=user_data, headers=self.headers)
        response.raise_for_status()
        return response.json()
    
    def delete(self, user_id):
        """Delete a user"""
        url = f"{self.base_url}/users/{user_id}"
        response = requests.delete(url, headers=self.headers)
        response.raise_for_status()
        return True

# Usage
api = UserAPI("https://api.example.com/api", "your_token")

# Create
new_user = api.create({"name": "Alice", "email": "alice@example.com"})

# Read
users = api.read_all(page=1, per_page=10)
user = api.read_one(123)

# Update
updated = api.update(123, {"name": "Alice Smith", "email": "alice@example.com"})
patched = api.partial_update(123, {"email": "newemail@example.com"})

# Delete
api.delete(123)
```

---

## POSTMAN (Optional)

**Postman** is a popular API development and testing tool.

### Key Features

1. **Send HTTP Requests**: Test GET, POST, PUT, DELETE, etc.
2. **Environment Variables**: Store and reuse values
3. **Collections**: Organize related API requests
4. **Testing**: Write automated tests
5. **Documentation**: Generate API documentation

### Basic Usage

#### 1. Creating a Request

```
Method: GET
URL: https://api.example.com/users
Headers:
  - Authorization: Bearer your_token
  - Content-Type: application/json
```

#### 2. Using Environment Variables

```javascript
// Set variable
pm.environment.set("base_url", "https://api.example.com");
pm.environment.set("token", "your_token_here");

// Use variable
URL: {{base_url}}/users
Header: Authorization: Bearer {{token}}
```

#### 3. Writing Tests in Postman

```javascript
// Test: Status code is 200
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

// Test: Response time is less than 200ms
pm.test("Response time is acceptable", function () {
    pm.expect(pm.response.responseTime).to.be.below(200);
});

// Test: Response has specific field
pm.test("Response has user data", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData).to.have.property('data');
    pm.expect(jsonData.data).to.have.property('name');
});

// Test: Save response data to variable
var jsonData = pm.response.json();
pm.environment.set("user_id", jsonData.data.id);
```

#### 4. Pre-request Scripts

```javascript
// Generate random email
pm.environment.set("random_email", `user${Math.random()}@example.com`);

// Set current timestamp
pm.environment.set("timestamp", new Date().toISOString());

// Generate random number
pm.environment.set("random_id", Math.floor(Math.random() * 1000));
```

#### 5. Collection Runner

Run multiple requests sequentially with automated testing.

```
1. Create collection
2. Add requests with tests
3. Click "Runner"
4. Select collection
5. Set iterations
6. Run collection
```

### Postman Alternatives

- **Insomnia**: Modern REST client
- **Thunder Client**: VS Code extension
- **cURL**: Command-line tool
- **HTTPie**: Command-line HTTP client

---

## Optimization and Efficiency

### 1. Caching

Store frequently accessed data to reduce API calls.

```python
import requests
from functools import lru_cache
import time

# Simple caching with lru_cache
@lru_cache(maxsize=128)
def get_user(user_id):
    """Cached API call"""
    response = requests.get(f"https://api.example.com/users/{user_id}")
    return response.json()

# First call: Makes API request
user1 = get_user(123)  # API call

# Second call: Returns cached result
user2 = get_user(123)  # No API call


# Manual caching with expiration
class CachedAPI:
    def __init__(self, ttl=300):
        self.cache = {}
        self.ttl = ttl  # Time to live in seconds
    
    def get_user(self, user_id):
        cache_key = f"user_{user_id}"
        
        # Check if cached and not expired
        if cache_key in self.cache:
            cached_time, cached_data = self.cache[cache_key]
            if time.time() - cached_time < self.ttl:
                print("Returning cached data")
                return cached_data
        
        # Make API call
        print("Making API call")
        response = requests.get(f"https://api.example.com/users/{user_id}")
        data = response.json()
        
        # Cache the result
        self.cache[cache_key] = (time.time(), data)
        return data

# Usage
api = CachedAPI(ttl=60)  # 60 second cache
user = api.get_user(123)
```

### 2. Pagination

Retrieve large datasets in chunks.

```python
def get_all_users_paginated(base_url, token):
    """Fetch all users using pagination"""
    all_users = []
    page = 1
    per_page = 100
    
    while True:
        response = requests.get(
            f"{base_url}/users",
            params={"page": page, "per_page": per_page},
            headers={"Authorization": f"Bearer {token}"}
        )
        
        data = response.json()
        users = data['data']
        
        if not users:
            break  # No more users
        
        all_users.extend(users)
        page += 1
        
        # Check if we've reached the last page
        if page > data['pagination']['total_pages']:
            break
    
    return all_users

# Usage
all_users = get_all_users_paginated("https://api.example.com/api", "token")
print(f"Total users: {len(all_users)}")
```

### 3. Batch Requests

Send multiple requests in a single API call.

```python
def batch_create_users(users_data):
    """Create multiple users in one request"""
    url = "https://api.example.com/api/users/batch"
    payload = {
        "users": users_data
    }
    
    response = requests.post(url, json=payload)
    return response.json()

# Usage
users = [
    {"name": "Alice", "email": "alice@example.com"},
    {"name": "Bob", "email": "bob@example.com"},
    {"name": "Charlie", "email": "charlie@example.com"}
]

result = batch_create_users(users)
```

### 4. Asynchronous Requests

Make multiple API calls concurrently.

```python
import asyncio
import aiohttp

async def fetch_user(session, user_id):
    """Async function to fetch a single user"""
    url = f"https://api.example.com/users/{user_id}"
    async with session.get(url) as response:
        return await response.json()

async def fetch_multiple_users(user_ids):
    """Fetch multiple users concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_user(session, user_id) for user_id in user_ids]
        results = await asyncio.gather(*tasks)
        return results

# Usage
user_ids = [1, 2, 3, 4, 5]
users = asyncio.run(fetch_multiple_users(user_ids))
print(users)


# Using concurrent.futures (alternative)
import concurrent.futures

def fetch_user_sync(user_id):
    """Synchronous fetch function"""
    response = requests.get(f"https://api.example.com/users/{user_id}")
    return response.json()

def fetch_multiple_users_concurrent(user_ids):
    """Fetch users using thread pool"""
    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        results = list(executor.map(fetch_user_sync, user_ids))
    return results

# Usage
user_ids = [1, 2, 3, 4, 5]
users = fetch_multiple_users_concurrent(user_ids)
```

### 5. Connection Pooling

Reuse connections to improve performance.

```python
import requests

# Create a session for connection pooling
session = requests.Session()

# Configure connection pooling
adapter = requests.adapters.HTTPAdapter(
    pool_connections=10,
    pool_maxsize=20,
    max_retries=3
)
session.mount('http://', adapter)
session.mount('https://', adapter)

# Set default headers
session.headers.update({
    'Authorization': 'Bearer your_token',
    'Content-Type': 'application/json'
})

# Make requests (reuses connections)
for i in range(100):
    response = session.get(f"https://api.example.com/users/{i}")
    print(response.status_code)

# Close session when done
session.close()
```

### 6. Rate Limiting

Respect API rate limits to avoid throttling.

```python
import time
from datetime import datetime, timedelta

class RateLimiter:
    """Simple rate limiter"""
    
    def __init__(self, max_calls, time_period):
        self.max_calls = max_calls
        self.time_period = time_period  # in seconds
        self.calls = []
    
    def __call__(self, func):
        def wrapper(*args, **kwargs):
            now = datetime.now()
            
            # Remove old calls outside time window
            self.calls = [call_time for call_time in self.calls 
                         if now - call_time < timedelta(seconds=self.time_period)]
            
            if len(self.calls) >= self.max_calls:
                # Wait until we can make another call
                sleep_time = (self.calls[0] + timedelta(seconds=self.time_period) - now).total_seconds()
                if sleep_time > 0:
                    print(f"Rate limit reached. Sleeping for {sleep_time:.2f} seconds")
                    time.sleep(sleep_time)
                    self.calls = []
            
            self.calls.append(now)
            return func(*args, **kwargs)
        
        return wrapper

# Usage
@RateLimiter(max_calls=10, time_period=60)  # 10 calls per minute
def make_api_call(endpoint):
    response = requests.get(f"https://api.example.com/{endpoint}")
    return response.json()

# This will automatically rate limit
for i in range(50):
    data = make_api_call(f"users/{i}")
```

### 7. Error Handling and Retries

```python
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

def create_session_with_retries():
    """Create session with automatic retries"""
    session = requests.Session()
    
    retry_strategy = Retry(
        total=3,  # Total retries
        backoff_factor=1,  # Wait 1, 2, 4 seconds between retries
        status_forcelist=[429, 500, 502, 503, 504],  # Retry on these status codes
        allowed_methods=["HEAD", "GET", "OPTIONS", "POST"]
    )
    
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    return session

# Usage
session = create_session_with_retries()

try:
    response = session.get("https://api.example.com/users")
    response.raise_for_status()
    data = response.json()
except requests.exceptions.RequestException as e:
    print(f"Error: {e}")
```

### 8. Compression

Request compressed responses to reduce bandwidth.

```python
import requests

# Request gzip compression
headers = {
    'Accept-Encoding': 'gzip, deflate'
}

response = requests.get(
    "https://api.example.com/large-dataset",
    headers=headers
)

# Response is automatically decompressed
data = response.json()
print(f"Content size: {len(response.content)} bytes")
```

---

## Requests Library in Python

The `requests` library is the most popular HTTP library for Python.

### Installation

```bash
pip install requests
```

### Basic Usage

```python
import requests

# GET request
response = requests.get("https://api.example.com/users")

# Access response
print(response.status_code)  # 200
print(response.headers)      # Response headers
print(response.text)         # Response body as text
print(response.json())       # Parse JSON response
print(response.content)      # Response body as bytes
```

### Request Methods

```python
import requests

# GET
response = requests.get("https://api.example.com/users")

# POST
response = requests.post(
    "https://api.example.com/users",
    json={"name": "Alice", "email": "alice@example.com"}
)

# PUT
response = requests.put(
    "https://api.example.com/users/123",
    json={"name": "Alice Smith", "email": "alice@example.com"}
)

# PATCH
response = requests.patch(
    "https://api.example.com/users/123",
    json={"email": "newemail@example.com"}
)

# DELETE
response = requests.delete("https://api.example.com/users/123")

# HEAD (get headers only)
response = requests.head("https://api.example.com/users")

# OPTIONS (get allowed methods)
response = requests.options("https://api.example.com/users")
```

### Passing Parameters

```python
# Query parameters
params = {
    "page": 1,
    "per_page": 20,
    "sort": "name",
    "order": "asc"
}

response = requests.get("https://api.example.com/users", params=params)
# URL: https://api.example.com/users?page=1&per_page=20&sort=name&order=asc
```

### Custom Headers

```python
headers = {
    "Authorization": "Bearer your_token_here",
    "Content-Type": "application/json",
    "User-Agent": "MyApp/1.0",
    "Accept": "application/json"
}

response = requests.get("https://api.example.com/users", headers=headers)
```

### Request Body

```python
# JSON body
data = {
    "name": "Alice",
    "email": "alice@example.com",
    "age": 30
}

# Method 1: Using json parameter (recommended)
response = requests.post("https://api.example.com/users", json=data)

# Method 2: Using data parameter with JSON string
import json
response = requests.post(
    "https://api.example.com/users",
    data=json.dumps(data),
    headers={"Content-Type": "application/json"}
)

# Form data
form_data = {
    "username": "alice",
    "password": "secret123"
}
response = requests.post("https://api.example.com/login", data=form_data)
```

### File Upload

```python
# Upload single file
files = {
    'file': open('document.pdf', 'rb')
}
response = requests.post("https://api.example.com/upload", files=files)

# Upload with additional data
files = {
    'file': open('image.jpg', 'rb')
}
data = {
    'title': 'My Image',
    'description': 'A beautiful landscape'
}
response = requests.post(
    "https://api.example.com/upload",
    files=files,
    data=data
)

# Upload multiple files
files = {
    'file1': open('doc1.pdf', 'rb'),
    'file2': open('doc2.pdf', 'rb')
}
response = requests.post("https://api.example.com/upload", files=files)
```

### Timeout

```python
# Set timeout (in seconds)
try:
    response = requests.get("https://api.example.com/users", timeout=5)
except requests.exceptions.Timeout:
    print("Request timed out")

# Separate timeouts for connection and read
response = requests.get(
    "https://api.example.com/users",
    timeout=(3, 10)  # 3 seconds to connect, 10 seconds to read
)
```

### Authentication

```python
from requests.auth import HTTPBasicAuth, HTTPDigestAuth

# Basic Authentication
response = requests.get(
    "https://api.example.com/users",
    auth=HTTPBasicAuth('username', 'password')
)

# Shorthand for basic auth
response = requests.get(
    "https://api.example.com/users",
    auth=('username', 'password')
)

# Digest Authentication
response = requests.get(
    "https://api.example.com/users",
    auth=HTTPDigestAuth('username', 'password')
)

# Bearer Token
headers = {"Authorization": "Bearer your_token"}
response = requests.get("https://api.example.com/users", headers=headers)
```

### Sessions

```python
# Create session (maintains cookies, headers across requests)
session = requests.Session()

# Set default headers for all requests
session.headers.update({
    'Authorization': 'Bearer your_token',
    'User-Agent': 'MyApp/1.0'
})

# Make requests
response1 = session.get("https://api.example.com/users")
response2 = session.get("https://api.example.com/posts")

# Login example with session (maintains cookies)
session = requests.Session()

# Login
login_data = {"username": "alice", "password": "secret"}
session.post("https://api.example.com/login", data=login_data)

# Subsequent requests use the session cookie
response = session.get("https://api.example.com/profile")
```

### Error Handling

```python
import requests

try:
    response = requests.get("https://api.example.com/users", timeout=5)
    
    # Raise exception for 4xx and 5xx status codes
    response.raise_for_status()
    
    data = response.json()
    print(data)

except requests.exceptions.HTTPError as http_err:
    print(f"HTTP error occurred: {http_err}")
    print(f"Status code: {response.status_code}")

except requests.exceptions.ConnectionError:
    print("Connection error occurred")

except requests.exceptions.Timeout:
    print("Request timed out")

except requests.exceptions.RequestException as err:
    print(f"An error occurred: {err}")

except ValueError:
    print("Invalid JSON response")
```

### Downloading Files

```python
import requests

# Download file
url = "https://example.com/file.pdf"
response = requests.get(url)

# Save to file
with open('downloaded_file.pdf', 'wb') as f:
    f.write(response.content)

# Stream large files (memory efficient)
url = "https://example.com/large_file.zip"
response = requests.get(url, stream=True)

with open('large_file.zip', 'wb') as f:
    for chunk in response.iter_content(chunk_size=8192):
        f.write(chunk)

# With progress tracking
import os

response = requests.get(url, stream=True)
total_size = int(response.headers.get('content-length', 0))
downloaded = 0

with open('file.zip', 'wb') as f:
    for chunk in response.iter_content(chunk_size=8192):
        downloaded += len(chunk)
        f.write(chunk)
        progress = (downloaded / total_size) * 100
        print(f"Downloaded: {progress:.2f}%", end='\r')
```

### Response Object Properties

```python
response = requests.get("https://api.example.com/users")

# Status
print(response.status_code)      # 200
print(response.ok)                # True (if status < 400)
print(response.reason)            # 'OK'

# Headers
print(response.headers)           # CaseInsensitiveDict
print(response.headers['Content-Type'])  # 'application/json'

# Content
print(response.text)              # Response as string
print(response.content)           # Response as bytes
print(response.json())            # Parse JSON

# URL
print(response.url)               # Final URL (after redirects)

# Cookies
print(response.cookies)           # RequestsCookieJar

# Encoding
print(response.encoding)          # 'utf-8'

# Request info
print(response.request.method)    # 'GET'
print(response.request.url)       # Request URL
print(response.request.headers)   # Request headers

# Elapsed time
print(response.elapsed.total_seconds())  # Request duration
```

---

## RBAC (Optional)

**Role-Based Access Control** - A method of restricting system access based on user roles.

### Key Concepts

- **User**: A person or service accessing the system
- **Role**: A collection of permissions (e.g., Admin, Editor, Viewer)
- **Permission**: An action that can be performed (e.g., create, read, update, delete)
- **Resource**: An entity that access is granted to (e.g., users, posts, files)

### RBAC Implementation Example

```python
from enum import Enum
from typing import List, Set

# Define Permissions
class Permission(Enum):
    CREATE_USER = "create:user"
    READ_USER = "read:user"
    UPDATE_USER = "update:user"
    DELETE_USER = "delete:user"
    CREATE_POST = "create:post"
    READ_POST = "read:post"
    UPDATE_POST = "update:post"
    DELETE_POST = "delete:post"

# Define Roles
class Role:
    def __init__(self, name: str, permissions: Set[Permission]):
        self.name = name
        self.permissions = permissions
    
    def has_permission(self, permission: Permission) -> bool:
        return permission in self.permissions

# Create predefined roles
ROLES = {
    "admin": Role("admin", {
        Permission.CREATE_USER,
        Permission.READ_USER,
        Permission.UPDATE_USER,
        Permission.DELETE_USER,
        Permission.CREATE_POST,
        Permission.READ_POST,
        Permission.UPDATE_POST,
        Permission.DELETE_POST,
    }),
    "editor": Role("editor", {
        Permission.READ_USER,
        Permission.CREATE_POST,
        Permission.READ_POST,
        Permission.UPDATE_POST,
    }),
    "viewer": Role("viewer", {
        Permission.READ_USER,
        Permission.READ_POST,
    })
}

# User class with roles
class User:
    def __init__(self, username: str, roles: List[str]):
        self.username = username
        self.roles = [ROLES[role] for role in roles if role in ROLES]
    
    def has_permission(self, permission: Permission) -> bool:
        """Check if user has specific permission"""
        return any(role.has_permission(permission) for role in self.roles)
    
    def has_role(self, role_name: str) -> bool:
        """Check if user has specific role"""
        return any(role.name == role_name for role in self.roles)

# Authorization decorator
def require_permission(permission: Permission):
    """Decorator to check if user has required permission"""
    def decorator(func):
        def wrapper(user: User, *args, **kwargs):
            if not user.has_permission(permission):
                raise PermissionError(
                    f"User '{user.username}' lacks permission: {permission.value}"
                )
            return func(user, *args, **kwargs)
        return wrapper
    return decorator

# Example protected functions
@require_permission(Permission.CREATE_USER)
def create_user(current_user: User, new_user_data: dict):
    """Create a new user (admin only)"""
    print(f"{current_user.username} is creating user: {new_user_data['username']}")
    return {"status": "success", "user": new_user_data}

@require_permission(Permission.DELETE_POST)
def delete_post(current_user: User, post_id: int):
    """Delete a post"""
    print(f"{current_user.username} deleted post: {post_id}")
    return {"status": "success"}

# Usage
admin = User("alice", ["admin"])
editor = User("bob", ["editor"])

create_user(admin, {"username": "newuser"})  # Success
delete_post(editor, 123)  # Success
```